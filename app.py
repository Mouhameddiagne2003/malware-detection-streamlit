import streamlit as st
import requests
import pickle
import pandas as pd
import hashlib
import pefile
import tempfile
import os
from sklearn.ensemble import RandomForestClassifier

# Charger le modèle Random Forest optimisé
with open("optimized_rf_model.pkl", "rb") as f:
    best_rf_model = pickle.load(f)

# Charger le scaler
with open("scaler_supervisee.pkl", "rb") as f:
    scaler = pickle.load(f)

# Clé API VirusTotal
API_KEY = "26d58f516b843375674d6998488de3367c59ec9a6e302fbcdc789548029fa114" 
API_URL = "https://www.virustotal.com/api/v3/files/"

def query_virustotal(file_hash):
    headers = {"x-apikey": API_KEY}
    response = requests.get(API_URL + file_hash, headers=headers)
    if response.status_code == 200:
        return response.json()
    else:
        st.error(f"Erreur API VirusTotal : {response.status_code}")
        return None

def extract_features(file_path):
    """
    Extraire les caractéristiques pertinentes à partir d'un fichier PE.
    """
    try:
        pe = pefile.PE(file_path)

        resource_size = 0
        # Parcourir les sections du fichier PE
        for section in pe.sections:
            if section.Name.startswith(b'.rsrc'):  # Identifier la section .rsrc
                resource_size = section.SizeOfRawData  # Taille brute des ressources

        features = {
            "AddressOfEntryPoint": pe.OPTIONAL_HEADER.AddressOfEntryPoint,
            "MajorLinkerVersion": pe.OPTIONAL_HEADER.MajorLinkerVersion,
            "MajorImageVersion": pe.OPTIONAL_HEADER.MajorImageVersion,
            "MajorOperatingSystemVersion": pe.OPTIONAL_HEADER.MajorOperatingSystemVersion,
            "DllCharacteristics": pe.OPTIONAL_HEADER.DllCharacteristics,
            "SizeOfStackReserve": pe.OPTIONAL_HEADER.SizeOfStackReserve,
            "NumberOfSections": len(pe.sections),
            "ResourceSize" :  resource_size
            }
        return features
    except Exception as e:
        st.error(f"Erreur lors de l'extraction des features : {e}")
        return None

def save_uploaded_file(uploaded_file):
    """
    Sauvegarder le fichier uploadé temporairement pour analyse.
    """
    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix='.exe') as tmp_file:
            tmp_file.write(uploaded_file.getvalue())
            return tmp_file.name
    except Exception as e:
        st.error(f"Erreur lors de la sauvegarde du fichier : {e}")
        return None

def calculate_sha256(file_path):
    """
    Calculer le hash SHA256 du fichier.
    """
    sha256_hash = hashlib.sha256()
    try:
        with open(file_path, "rb") as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()
    except Exception as e:
        st.error(f"Erreur lors du calcul SHA256 : {e}")
        return None

def classify_file(features):
    """
    Classifie un fichier en utilisant le modèle Random Forest.
    """
    feature_names = ["AddressOfEntryPoint", "MajorLinkerVersion", "MajorImageVersion",
                     "MajorOperatingSystemVersion", "DllCharacteristics", 
                     "SizeOfStackReserve", "NumberOfSections","ResourceSize"]
    
    # Mise à l'échelle des features
    features_df = pd.DataFrame([features], columns=feature_names)
    features_scaled = scaler.transform(features_df)
    
    # Prédiction avec le modèle Random Forest
    prediction = best_rf_model.predict(features_scaled)[0]
    probability = best_rf_model.predict_proba(features_scaled)[0]
    return prediction, probability

# Interface Streamlit
st.title("Détection de Malware avec Random Forest")
st.write("Analysez un exécutable et découvrez s'il s'agit d'un malware ou d'un fichier légitime.")

uploaded_file = st.file_uploader("Téléversez un fichier exécutable (.exe)", type=["exe"])

if uploaded_file:
    st.write("Analyse en cours...")
    
    temp_file_path = save_uploaded_file(uploaded_file)
    
    if temp_file_path:
        try:
            features = extract_features(temp_file_path)
            sha256_hash = calculate_sha256(temp_file_path)
            st.write(f"Hachage SHA256 : {sha256_hash}")
            
            if features and sha256_hash:
                # vt_response = query_virustotal(sha256_hash)
                
                st.write("Caractéristiques extraites :", features)
                prediction, probability = classify_file(features)
                
                # Affichage du résultat
                if prediction == 1:
                    st.error(f"Résultat : Malware détecté (probabilité : {probability[1]:.2%})")
                else:
                    st.success(f"Résultat : Fichier légitime (probabilité : {probability[0]:.2%})")
                
        finally:
            try:
                os.remove(temp_file_path)
            except:
                pass
    else:
        st.error("Impossible de traiter le fichier uploadé")
